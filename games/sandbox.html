<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<title>Fambam ‚Äî Sandbox</title>
<style>
  :root{ --bg:#0b1220; --text:#e5e7eb; --btn:#1f2937; --btnBorder:#334155; --accent:#22d3ee; }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; overscroll-behavior:none;
  }
  #world{ position:fixed; inset:0; display:block; background:#0b1220; touch-action:none; }
  .bar{
    position:fixed; left:12px; right:12px; top:12px; z-index:9999;
    display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    background:rgba(17,24,39,.85); border:1px solid #243244; backdrop-filter:blur(6px);
    padding:8px; border-radius:12px;
  }
  .btn{
    appearance:none; font:inherit; color:var(--text); background:var(--btn);
    border:1px solid var(--btnBorder); border-radius:10px; padding:8px 10px; cursor:pointer; user-select:none;
  }
  .btn[data-on="1"]{ outline:2px solid var(--accent) }
  .sep{ width:1px; height:28px; background:#243244; margin:0 2px }
  .row{ display:flex; gap:8px; align-items:center }
  .tag{ opacity:.85 }
  .back{
    position:fixed; left:12px; bottom:12px; z-index:10000;
    background:rgba(17,24,39,.85); border:1px solid #243244; padding:8px 12px; border-radius:10px;
    text-decoration:none; color:var(--text)
  }
</style>
</head>
<body>
  <div class="bar" id="ui">
    <button class="btn" data-tool="wood">ü™µ Wood</button>
    <button class="btn" data-tool="metal">üî© Metal</button>
    <button class="btn" data-tool="robot">ü§ñ Robot</button>
    <div class="sep"></div>
    <button class="btn" data-tool="water">üíß Water</button>
    <button class="btn" data-tool="fire">üî• Fire</button>
    <button class="btn" data-tool="acid">üß™ Acid</button>
    <div class="sep"></div>
    <button class="btn" data-tool="hand" data-on="1">‚úã Move</button>
    <button class="btn" id="btnDelete">üßπ Delete</button>
    <div class="sep"></div>
    <button class="btn" id="btnPause">‚è∏Ô∏è Pause</button>
    <div class="row">
      <span class="tag">Gravity</span>
      <input id="grav" type="range" min="0" max="2000" value="800">
    </div>
    <button class="btn" id="btnReset">‚Ü∫ Reset</button>
  </div>

  <!-- back to /fambam/games.html -->
  <a class="back" href="../games.html">‚Üê Games</a>

  <canvas id="world"></canvas>

<script>
/* Stop Safari‚Äôs browser-level pinch gestures competing with our pinch */
['gesturestart','gesturechange','gestureend'].forEach(function(evt){
  window.addEventListener(evt, function(e){ e.preventDefault(); }, {passive:false});
});

(function(){
  var cvs = document.getElementById('world');
  var ctx = cvs.getContext('2d');

  // Block two-finger browser zoom on the canvas; we handle pinch ourselves
  cvs.addEventListener('touchmove', function(e){
    if (e.touches && e.touches.length > 1) e.preventDefault();
  }, {passive:false});

  /* View / canvas sizing */
  var W=innerWidth, H=innerHeight, DPR=window.devicePixelRatio||1;
  var scale=1, camX=0, camY=0;

  function resize(){
    W = innerWidth; H = innerHeight; DPR = window.devicePixelRatio||1;
    cvs.width  = Math.round(W*DPR);
    cvs.height = Math.round(H*DPR);
    cvs.style.width = W+'px';
    cvs.style.height= H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    rebuildGrid();                // ensure grid exists
  }
  window.addEventListener('resize', resize, false);
  resize();

  /* World */
  var gravity = { y: 800 };
  var bounds  = { left:-2000, right:2000, top:-2000, bottom:1200 };

  var MAT_WOOD = { name:'wood', hp:100, fill:'#9a6e4c', stroke:'#e9d5b5' };
  var MAT_METAL= { name:'metal',hp:220, fill:'#5b6775', stroke:'#cbd5e1' };

  var bodies=[], nextId=1;
  function addBox(x,y,w,h,mat,opts){
    opts = opts||{};
    bodies.push({
      id:nextId++, x:x,y:y, w:w,h:h, vx:0,vy:0,
      static:!!opts.static, mat:mat, hp: (typeof opts.hp==='number'? opts.hp : mat.hp)
    });
  }
  function seed(){
    bodies.length=0;
    addBox(-800, 900, 1600, 60, MAT_METAL, {static:true}); // floor
    addBox(-60, 200, 120, 60, MAT_WOOD);
    addBox( 90, 100, 120, 60, MAT_METAL);
    clearFluids();
  }
  seed();

  /* Fluids (grid centered on world origin so negative coords work) */
  var CELL=4, gw=0, gh=0, grid=null, heat=null, gcx=0, gcy=0;
  var G_EMPTY=0, G_WATER=1, G_FIRE=2, G_ACID=3, G_OIL=4;

  function rebuildGrid(){
    gw = Math.ceil((W/scale)/CELL) + 256;
    gh = Math.ceil((H/scale)/CELL) + 256;
    gcx = (gw>>1);            // grid center index (world x=0 maps here)
    gcy = (gh>>1);            // grid center index (world y=0 maps here)
    grid = new Uint8Array(gw*gh);
    heat = new Uint8Array(gw*gh);
  }
  function clearFluids(){ if(grid) grid.fill(0); if(heat) heat.fill(0); }

  function gi(x,y){ return y*gw + x; }
  function inG(gx,gy){ return gx>=0 && gy>=0 && gx<gw && gy<gh; }

  // Convert world‚Üígrid indices with center offset
  function w2g(wx,wy){
    var gx = Math.floor(wx/CELL) + gcx;
    var gy = Math.floor(wy/CELL) + gcy;
    return [gx,gy];
  }
  // For drawing, convert grid‚Üíworld (top-left of cell)
  function g2wx(gx){ return (gx - gcx) * CELL; }
  function g2wy(gy){ return (gy - gcy) * CELL; }

  function staticCell(gx,gy){
    var wx = g2wx(gx) + CELL*0.5, wy = g2wy(gy) + CELL*0.5;
    for (var i=0;i<bodies.length;i++){
      var b=bodies[i]; if(!b.static) continue;
      if (wx>=b.x && wx<=b.x+b.w && wy>=b.y && wy<=b.y+b.h) return true;
    }
    return false;
  }

  function setCellWorld(wx,wy,type){
    var gg = w2g(wx,wy), gx=gg[0], gy=gg[1];
    if(!inG(gx,gy)) return;
    grid[gi(gx,gy)] = type;
    if (type===G_FIRE) heat[gi(gx,gy)] = 255;
  }
  function brush(wx,wy,type,r){
    for(var y=-r;y<=r;y++){
      for(var x=-r;x<=r;x++){
        if (x*x + y*y <= r*r) setCellWorld(wx + x*CELL, wy + y*CELL, type);
      }
    }
  }
  function swap(i,j){ var t=grid[i]; grid[i]=grid[j]; grid[j]=t; }
  function nbrHas(x,y,type){
    return (inG(x-1,y)&&grid[gi(x-1,y)]===type) ||
           (inG(x+1,y)&&grid[gi(x+1,y)]===type) ||
           (inG(x,y-1)&&grid[gi(x,y-1)]===type) ||
           (inG(x,y+1)&&grid[gi(x,y+1)]===type);
  }
  function stepGrid(){
    if(!grid) return;
    var dir = (tick&1)?1:-1, x,y,i,dl,dr,canDL,canDR,side,si;

    // gravity-like behavior
    for(y=gh-2;y>=1;y--){
      for(x=(dir>0?1:gw-2); x!==(dir>0?gw-1:0); x+=dir){
        i = gi(x,y); var t = grid[i];
        if (t===G_EMPTY || t===G_FIRE) continue;

        // down
        if (grid[gi(x,y+1)]===G_EMPTY && !staticCell(x,y+1)){ swap(i, gi(x,y+1)); continue; }
        // diagonals
        dl=gi(x-1,y+1); dr=gi(x+1,y+1);
        canDL = inG(x-1,y+1) && grid[dl]===G_EMPTY && !staticCell(x-1,y+1);
        canDR = inG(x+1,y+1) && grid[dr]===G_EMPTY && !staticCell(x+1,y+1);
        if (canDL && canDR){ swap(i, Math.random()<0.5?dl:dr); continue; }
        if (canDL){ swap(i, dl); continue; }
        if (canDR){ swap(i, dr); continue; }

        // sideways seep
        if (t===G_WATER || t===G_OIL || t===G_ACID){
          side = Math.random()<0.5?-1:1; si=gi(x+side,y);
          if (inG(x+side,y) && grid[si]===G_EMPTY && !staticCell(x+side,y)) swap(i,si);
        }
      }
    }

    // fire heat + quench
    for(y=1;y<gh-1;y++){
      for(x=1;x<gw-1;x++){
        i=gi(x,y);
        if(grid[i]===G_FIRE){
          if (nbrHas(x,y,G_WATER)) { grid[i]=G_EMPTY; continue; }
          heat[i]=255;
          var n=[i-1,i+1,i-gw,i+gw], k;
          for(k=0;k<n.length;k++){ var j=n[k]; if(j>=0&&j<heat.length) heat[j]=Math.min(255, heat[j]+6); }
          if (Math.random()<0.01) grid[i]=G_EMPTY;
        }else{
          heat[i]=Math.max(0,heat[i]-1);
        }
      }
    }
  }

  /* UI wiring */
  var ui = document.getElementById('ui');
  var toolBtns = ui.querySelectorAll('.btn[data-tool]');
  var btnDelete = document.getElementById('btnDelete');
  var btnPause  = document.getElementById('btnPause');
  var btnReset  = document.getElementById('btnReset');
  var grav      = document.getElementById('grav');

  var state = { tool:'hand', deleting:false, paused:false };

  function selectTool(t){
    for(var i=0;i<toolBtns.length;i++) toolBtns[i].dataset.on='0';
    state.tool=t;
    for(var j=0;j<toolBtns.length;j++){
      if (toolBtns[j].getAttribute('data-tool')===t){ toolBtns[j].dataset.on='1'; break; }
    }
    state.deleting=false; btnDelete.dataset.on='0';
  }
  for(var i=0;i<toolBtns.length;i++){
    toolBtns[i].addEventListener('click', (function(btn){
      return function(){ selectTool(btn.getAttribute('data-tool')); };
    })(toolBtns[i]), false);
  }

  btnDelete.addEventListener('click', function(){
    state.deleting=!state.deleting;
    btnDelete.dataset.on = state.deleting ? '1':'0';
  }, false);

  btnPause.addEventListener('click', function(){
    state.paused=!state.paused;
    btnPause.textContent = state.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
  }, false);

  btnReset.addEventListener('click', function(){ seed(); }, false);

  grav.addEventListener('input', function(e){ gravity.y = Number(e.target.value)||800; }, false);

  /* Input + ‚Äúthrowing‚Äù inertia */
  function screenToWorld(sx,sy){ return [sx/scale + camX, sy/scale + camY]; }

  var dragging=null, offX=0, offY=0;
  var panning=false, lastPX=0, lastPY=0;
  var lastWX=0, lastWY=0, lastTime=0;     // for inertia

  function pickBody(wx,wy){
    for (var i=bodies.length-1;i>=0;i--){
      var b=bodies[i];
      if (wx>=b.x && wx<=b.x+b.w && wy>=b.y && wy<=b.y+b.h) return b;
    }
    return null;
  }

  cvs.addEventListener('pointerdown', function(e){
    cvs.setPointerCapture(e.pointerId);
    var pt = screenToWorld(e.clientX, e.clientY), wx=pt[0], wy=pt[1];

    // middle-click / secondary touch ‚Üí pan
    if (e.button===1 || (e.pointerType==='touch' && e.isPrimary===false)){
      panning=true; lastPX=e.clientX; lastPY=e.clientY; return;
    }

    if (state.deleting){
      var b = pickBody(wx,wy);
      if (b && !b.static){ bodies.splice(bodies.indexOf(b),1); }
      else { brush(wx,wy,G_EMPTY,6); }
      return;
    }

    if (state.tool==='hand'){
      var hit = pickBody(wx,wy);
      if (hit && !hit.static){
        dragging=hit; offX=wx-hit.x; offY=wy-hit.y; hit.vx=0; hit.vy=0;
        lastWX=wx; lastWY=wy; lastTime=performance.now();
      }
    } else if (state.tool==='wood'){  addBox(wx-30,wy-20,60,40,MAT_WOOD); }
      else if (state.tool==='metal'){ addBox(wx-30,wy-20,60,40,MAT_METAL); }
      else if (state.tool==='robot'){ addBox(wx-40,wy-40,80,80,MAT_WOOD,{hp:130}); }
      else if (state.tool==='water'){ brush(wx,wy,G_WATER,8); }
      else if (state.tool==='fire'){  brush(wx,wy,G_FIRE,6); }
      else if (state.tool==='acid'){  brush(wx,wy,G_ACID,6); }
  }, false);

  cvs.addEventListener('pointermove', function(e){
    var pt = screenToWorld(e.clientX, e.clientY), wx=pt[0], wy=pt[1];

    if (panning){ camX -= (e.clientX-lastPX)/scale; camY -= (e.clientY-lastPY)/scale; lastPX=e.clientX; lastPY=e.clientY; return; }

    if (dragging){
      dragging.x = wx-offX; dragging.y = wy-offY;
      // sample velocity for throw
      var now = performance.now(), dt = (now - lastTime)/1000;
      if (dt>0){
        dragging.vx = (wx - lastWX)/dt * 0.9;   // a little damping
        dragging.vy = (wy - lastWY)/dt * 0.9;
      }
      lastWX=wx; lastWY=wy; lastTime=now;
      return;
    }

    // allow painting while finger is down on touch (buttons=0 on iOS)
    if (e.pointerType==='touch'){
      if (state.tool==='water') brush(wx,wy,G_WATER,8);
      if (state.tool==='fire')  brush(wx,wy,G_FIRE,6);
      if (state.tool==='acid')  brush(wx,wy,G_ACID,6);
    } else if (e.buttons & 1){
      if (state.tool==='water') brush(wx,wy,G_WATER,8);
      if (state.tool==='fire')  brush(wx,wy,G_FIRE,6);
      if (state.tool==='acid')  brush(wx,wy,G_ACID,6);
    }
  }, false);

  window.addEventListener('pointerup', function(){ panning=false; dragging=null; }, false);

  // Desktop wheel zoom
  cvs.addEventListener('wheel', function(e){
    e.preventDefault();
    var pt = screenToWorld(e.clientX, e.clientY), wx=pt[0], wy=pt[1];
    var k = (e.deltaY<0?1.12:0.9);
    scale = Math.max(0.3, Math.min(3, scale*k));
    camX = wx - (e.clientX/scale);
    camY = wy - (e.clientY/scale);
    rebuildGrid();
  }, {passive:false});

  // Touch pinch zoom
  var pinchPrev=0, midX=0, midY=0;
  cvs.addEventListener('touchstart', function(e){
    if (e.touches.length===2){
      pinchPrev = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      midX = (e.touches[0].clientX + e.touches[1].clientX)/2;
      midY = (e.touches[0].clientY + e.touches[1].clientY)/2;
    }
  }, false);

  cvs.addEventListener('touchmove', function(e){
    if (e.touches.length===2){
      e.preventDefault();
      var d = Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
      );
      var pt = screenToWorld(midX, midY), wx=pt[0], wy=pt[1];
      var k = d/(pinchPrev || d);
      pinchPrev = d;
      scale = Math.max(0.3, Math.min(3, scale*k));
      camX = wx - (midX/scale);
      camY = wy - (midY/scale);
      rebuildGrid();
    }
  }, {passive:false});

  /* Physics */
  function aabbOverlap(a,b){
    return !(a.x+a.w<=b.x || a.x>=b.x+b.w || a.y+a.h<=b.y || a.y>=b.y+b.h);
  }
  function resolveAABB(a,b){
    var dx1=(b.x+b.w)-a.x, dx2=(a.x+a.w)-b.x;
    var dy1=(b.y+b.h)-a.y, dy2=(a.y+a.h)-b.y;
    var minX = dx1<dx2 ? dx1 : -dx2;
    var minY = dy1<dy2 ? dy1 : -dy2;
    if (Math.abs(minX) < Math.abs(minY)){
      if (!a.static && !b.static){ a.x+=minX/2; b.x-=minX/2; a.vx*=0.8; b.vx*=0.8; }
      else if (!a.static){ a.x+=minX; a.vx*=-0.2; }
      else if (!b.static){ b.x-=minX; b.vx*=-0.2; }
    } else {
      if (!a.static && !b.static){ a.y+=minY/2; b.y-=minY/2; a.vy*=0.4; b.vy*=0.4; }
      else if (!a.static){ a.y+=minY; a.vy*=(minY<0?-0.05:0); a.vx*=0.9; }
      else if (!b.static){ b.y-=minY; b.vy*=(minY>0?-0.05:0); b.vx*=0.9; }
    }
  }
  function stepPhysics(dt){
    for(var i=0;i<bodies.length;i++){
      var b=bodies[i]; if (b.static) continue;
      b.vy += gravity.y*dt;
      b.x  += b.vx*dt;
      b.y  += b.vy*dt;

      if (b.y+b.h > bounds.bottom){ b.y=bounds.bottom-b.h; b.vy*=-0.12; b.vx*=0.98; }
      if (b.x < bounds.left){ b.x=bounds.left; b.vx*=-0.2; }
      if (b.x+b.w > bounds.right){ b.x=bounds.right-b.w; b.vx*=-0.2; }
      if (b.y < bounds.top){ b.y=bounds.top; b.vy*=0; }

      for(var j=0;j<bodies.length;j++){
        var c=bodies[j]; if (c===b || c.removed) continue;
        if (!aabbOverlap(b,c)) continue;
        resolveAABB(b,c);
      }
    }
  }

  /* Render */
  function draw(){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,W,H);
    ctx.save();
    ctx.translate(-camX*scale, -camY*scale);
    ctx.scale(scale, scale);

    // fluids (convert grid coords back to world)
    if (grid){
      var vis=CELL, x,y,t;
      for(y=0;y<gh;y++){
        for(x=0;x<gw;x++){
          t=grid[gi(x,y)]; if(!t) continue;
          if (t===G_WATER) ctx.fillStyle='rgba(96,165,250,0.9)';
          else if (t===G_OIL) ctx.fillStyle='rgba(120,89,61,0.9)';
          else if (t===G_ACID) ctx.fillStyle='rgba(34,197,94,0.9)';
          else if (t===G_FIRE) ctx.fillStyle='rgba(252,165,3,0.92)';
          ctx.fillRect(g2wx(x), g2wy(y), vis, vis);
        }
      }
    }

    // boxes
    for(var i=0;i<bodies.length;i++){
      var b=bodies[i];
      ctx.lineWidth=2;
      if (b.static){ ctx.fillStyle='#1f2937'; ctx.strokeStyle='#475569'; }
      else if (b.mat===MAT_WOOD){ ctx.fillStyle=MAT_WOOD.fill; ctx.strokeStyle=MAT_WOOD.stroke; }
      else { ctx.fillStyle=MAT_METAL.fill; ctx.strokeStyle=MAT_METAL.stroke; }
      ctx.fillRect(b.x,b.y,b.w,b.h);
      ctx.strokeRect(b.x,b.y,b.w,b.h);
    }

    ctx.restore();
  }

  /* Main loop */
  var last=0, tick=0;
  function frame(t){
    requestAnimationFrame(frame);
    var dt=Math.min(0.03, (t-last)/1000 || 0.016);
    last=t;
    if (!state.paused){ stepPhysics(dt); stepGrid(); tick++; }
    draw();
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
